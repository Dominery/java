# 底层实现原理

Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和CPU的指令。

### 高速缓存

处理器处理能力上要远胜于主内存（DRAM），为了弥补处理器与主内存处理能力之间的鸿沟，引入了高速缓存（Cache)，来保存一些CPU从内存读取的数据，下次用到该数据直接从缓存中获取即可，以加快读取速度。

#### 缓存类型

| 缓存名称             | 是还共享           | 描述                                                         |
| -------------------- | ------------------ | ------------------------------------------------------------ |
| 一级缓存（L1 Cache） | CPU CORE独享       | 制造成本很高因此它的容量有限，但是读取速度很快               |
| 二级缓存（L2 Cache） | CPU CORE独享       | 是一级缓存的缓冲器,存储那些CPU处理时需要用到、一级缓存又无法存储的数据，读取速度低于一级缓存 |
| 三级缓存（L3 Cache） | 多个CPU CORE共享的 | 可以看作是二级缓存的缓冲器，读写速度低于二级缓存，CPU主要通过三级缓存与总线通信 |

#### 缓存一致性

随着多核时代的到来，每块CPU都有多个内核，每个内核都有自己的缓存，这样就会出现同一个数据的副本就会存在于多个缓存中，在读写的时候就会出现数据不一致的情况。

缓存一致性协议用来解决数据不一致问题。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

### volatile

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。

> 可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

#### 实现原理

有volatile变量修饰的共享变量进行写操作的时候其汇编代码比普通变量多出Lock前缀的指令。该指令将完成两件事：

1. 将当前处理器缓存行的数据写回到系统内存。

   > LOCK指令在声明之后通过锁定总线，独占共享内存，在最近的处理器里，LOCK #信号一般不锁总线，而是锁缓存。

2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

   > 处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。

### synchronized

Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。

#### java对象头

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节。

| 长度  | 内容                   | 说明                   |
| ----- | ---------------------- | ---------------------- |
| 1word | Mark Word              | 对象的HashCode或锁信息 |
| 1word | Class Matadata Address | 对象类型数据指针       |
| 1word | Array length           | 数组长度               |

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。

#### 锁的升级

在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

1. 偏向锁

   大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

   当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。

2. 轻量级锁

   线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。

### 原子操作

原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。

#### 实现原理

32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。

处理器会自动保证基本的内存操作的原子性。但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。因而处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

1. 总线锁

   总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

2. 缓存锁

   频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，因而避免了锁定期间，其他处理器不能操作其他内存地址的数据的问题。

   缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性

   **不使用缓存锁定的情况**

   1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。
   2. 有些处理器不支持缓存锁定。

#### java实现原子操作

在Java中可以通过锁和循环CAS的方式来实现原子操作。

* 循环CAS

  JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。

* CAS的问题

  CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。

  1. ABA问题

     因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。

     从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。

  2. 只能保证一个共享变量的原子操作

     这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。

* 使用锁机制

  

