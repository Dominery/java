# 并行流

在本节中，你将了解Stream接口如何对数据集执行并行操作。它允许你声明性地将顺序流变为并行流。此外，你将看到流是如何在幕后应用Java 7引入的分支/合并框架的。

> 并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。

### 并行流的使用

#### 并行流的创建

Stream接口可以通过对收集源调用parallelStrem方法来把集合转换为并行流。

对于stream，可以调用parallel方法将顺序流转换为并行流，调用sequential方法能够将并行流转化为顺序流。

#### 并行流的性能

并行编程如果用得不对，它甚至可能让程序的整体性能更差。如果希望并行流提升程序性能，并行的流操作需要容易并行化。

并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价很大，所以很重要的一点是要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。

一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长；一个惯用方法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出同时进行。

#### 使用并行流的建议

1. 在考虑选择顺序流还是并行流时，最重要的建议就是用适当的基准来检查其性能。
2. 留意装箱。自动装箱和拆箱操作会大大降低性能。
3. 有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。
4. 考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。
5. 并行处理少数几个元素的好处还抵不上并行化造成的额外开销。
6. 考虑流背后的数据结构是否易于分解。
7. 流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。
8. 考虑终端操作中合并步骤的代价是大是小

#### 错误的使用

错用并行流而产生错误的首要原因，就是使用的算法改变了某些共享状态。共享可变状态会影响并行流以及并行计算，编程时要避免共享可变状态，确保并行Stream得到正确的结果。

### 分支/合并框架

分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。

#### RecursiveTask

要把任务提交到这个池，必须创建RecursiveTask<R>的一个子类，其中R是并行化任务（以及所有子任务）产生的结果类型，或者如果任务不返回结果，则RecursiveAction类型。

要定义RecursiveTask，只需实现它唯一的抽象方法compute。这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。

#### 使用框架建议

1. 对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。
2. 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。
3. 对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用compute低。
4. 和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。
5. 你必须选择一个标准，来决定任务是要进一步拆分还是已小到可以顺序求值。

#### 工作窃取

理想情况下，划分并行任务时，应该划分出大量小任务，让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。实际中，每个子任务所花的时间可能天差地别，要么是因为划分策略效率低，要么是有不可预知的原因，比如磁盘访问慢，或是需要和外部服务协调执行。

分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题。在实际应用中，这意味着这些任务差不多被平均分配到ForkJoinPool中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。

### Spliterator

Spliterator定义了并行流如何拆分它要遍历的数据。

> Spliterator是Java 8中加入的另一个新接口；这个名字代表“可分迭代器”（splitable iterator）。和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。
>
> Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。

```java
public interface Spliterator<T>{
    boolean tryAdvance(Consumer<? super T>action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```

> T是Spliterator遍历的元素的类型。
>
> tryAdvance方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。
>
> trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分给第二个Spliterator（由该方法返回），让它们两个并行处理。Spliterator还可通过estimateSize方法估计还剩下多少元素要遍历

#### 拆分过程

将Stream拆分成多个部分的算法是一个递归过程。

第一步是对第一个Spliterator调用trySplit，生成第二个Spliterator。第二步对这两个Spliterator调用trysplit，这样总共就有了四个Spliterator。这个框架不断对Spliterator调用trySplit直到它返回null，表明它处理的数据结构不能再分割。

这个拆分过程也受Spliterator本身的特性影响，而特性是通过characteristics方法声明的。

#### Spliterator的特性

Spliterator接口声明的最后一个抽象方法是characteristics，它将返回一个int，代表Spliterator本身特性集的编码。